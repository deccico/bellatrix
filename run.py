'''
Created on Aug 23, 2011

Starting point for the project.

ec2-upgraded is meant to automate the upgrade tasks to ec2 ami's.

this script needs "secret" and "key" files (with the correct EC2 credentials) in the current path

The idea is to:
    -start an instance
    -execute the correct upgrade steps  
    -burn the instance and save the new ami
'''

import logging
import os
import re
import pkgutil
import datetime

APP="Bellatrix"
FORMAT = '%(asctime)-15s %(levelname)s %(message)s'
logging.basicConfig(level=logging.INFO,
                    format=FORMAT,
                    #filename='out',
                    filemode='a'
                    )

from boto.ec2.connection import EC2Connection
from ec2_lib import Ec2lib

#this script needs "secret" and "key" files in the current path
SECRET = open("secret").read().strip()
KEY = open("key").read().strip()
CONFIG_DIR = "./configs"  #todo get the path from the script
OUT_TMP = "exec.tmp"
PK = os.path.abspath(os.path.dirname(os.path.realpath(__file__)) + os.path.sep + "ec2.pk")  #path to the private key to connect to agents


class Run():
    def __init__(self, key, sec, app_name, pk): #todo move all the globals here
        self.checkPkFile(pk)
        self._ec2 = Ec2lib(KEY, SECRET) 
        self._app_name = app_name
        self.CMD_OK = 0
        self.define_constants()

    def checkPkFile(self, pk):
        if not os.path.isfile(pk): #todo add more validations (in a method)
            raise Exception("%s does not contain the private key file" % pk)
        
    def define_constants(self):
        """define class constants to access ami configs"""
        self.AMIS = "amis"
        self.CMDS = "commands"
        self.USER = "user"
        self.BURN_OR_NOT = "burn_ami_at_the_end"
        self.SKIP_ME = "skip_me"
    
    def getEc2Instance(self, ami, key_name, security_group, instance_type, instance_initiated_shutdown_behavior="terminate"):
        image = self._ec2.getImage(ami)  
        inst = self._ec2.startInstance(image, key_name, security_group, instance_type, APP, instance_initiated_shutdown_behavior="terminate")
        return inst

    def getConfigs(self):
        """get configurations from 'configs' directory"""
        import configs
        cfgpath = os.path.dirname(configs.__file__)
        dir = os.path.basename(cfgpath)
        return [name for _, name, _ in pkgutil.iter_modules([cfgpath])]
        
    def executeCommands(self, user, dns, key, commands, config):
        results = []
        errors = []
        for c in commands:
            cmd = "ssh -o StrictHostKeyChecking=no -i %s %s@%s '%s' > %s" % (key, user, dns, c, OUT_TMP)
            logging.info("executing: " + cmd)
            res = os.system(cmd)
            out = open(OUT_TMP).read()
            cmd_res = [cmd, out, res, config]
            results.append(cmd_res)
            logging.info("result: " + str(res) + " output: " + out)
            #increment errors if necessary
            if res != 0:
                errors.append(cmd_res)
        logging.info("Commands executions: %s Errors: %s" % (len(commands), len(errors)))
        return results, errors

    def printErrors(self, errors):                
        logging.warning("The following commands failed its execution:")
        for e in errors:
            logging.warning("config: %s cmd: %s exit code: %s" % (e[3], e[0], e[2])) 
            logging.warning("last 500 chars output: %s" % e[1][-500:]) 
            
    def run(self):
        configs = self.getConfigs()
        amis_burned = []
        errors = []
        for config in configs:
            logging.info("processing: " + config)
            c = __import__(os.path.basename(CONFIG_DIR) + "." + config)
            mod = "c." + config + "."
            skip_me = eval(mod + self.SKIP_ME)
            if skip_me:
                logging.info("skipping execution of config: %s due to its configuration skip_me=true" % config)
                continue
            amis = eval(mod + self.AMIS)
            commands =  eval(mod + self.CMDS)
            user =  eval(mod + self.USER)
            burn_at_the_end = eval(mod + self.BURN_OR_NOT)
            for ami in amis:
                config_name = ami[1]
                ami = ami[0]
                inst = self.getEc2Instance(ami, "elasticbamboo", ["elasticbamboo"], 't1.micro')
                dns_name = self._ec2.getDNSName(inst)
                self._ec2.waitUntilInstanceIsReady(inst)
                self._ec2.waitForConnectionReady(inst, user, PK, dns_name)
                r, e = self.executeCommands(user, inst.dns_name, PK, commands, config_name)
                errors += e
                if burn_at_the_end:
                    new_ami = self._ec2.createImage(inst.id, config_name + "-" 
                                                    + datetime.datetime.now().isoformat(), "generated by " 
                                                    + self._app_name)
                    logging.info("ami: %s is being generated for configuration: %s" 
                                 % (new_ami, config_name))
                    amis_burned.append([new_ami, config_name])
            self.printErrors(errors)
            logging.info("total of ami's burned:%s" % len(amis_burned))
            for a in amis_burned:
                logging.info(str(a))

def run():
    r = Run(KEY, SECRET, APP, PK)
    r.run()

if __name__ == '__main__':
    logging.info("starting %s" % APP)
    run()
    logging.info("%s has finished" % APP)

